name: deploy.yml
# ============================================================================
# ALGENORD - BUILD AND PUSH TO GHCR (GitHub Container Registry)
# ============================================================================
# Dette workflow bygger Docker images og uploader dem til GitHub's container
# registry (ghcr.io). Dette g√∏r det muligt at deploye applikationen p√• en
# server uden at bygge images lokalt.
#
# Flowet er:
# 1. Byg Docker image fra Dockerfile
# 2. Test at containeren faktisk virker (integrationstest)
# 3. Upload image til ghcr.io s√• servere kan hente det
#
# Filen skal hedde: .github/workflows/ghcr.yaml
# ============================================================================


# ============================================================================
# TRIGGERS - Hvorn√•r skal workflow k√∏re?
# ============================================================================
# "on:" definerer hvilke events der starter dette workflow.
# Vi vil bygge og teste ved PRs, men kun pushe til GHCR ved merge til main.

on:
  # push: K√∏rer n√•r commits pushes direkte til main branch.
  # Dette er typisk n√•r en PR merges.
  push:
    branches: ["main"]
  # workflow_dispatch: Tillader manuel k√∏rsel fra GitHub's UI.
  # Nyttigt til debugging eller hvis man vil genbygge uden at pushe kode.
  workflow_dispatch:


# ============================================================================
# PERMISSIONS - Hvilke rettigheder har workflow?
# ============================================================================
# GitHub Actions bruger GITHUB_TOKEN til at interagere med repository.
# Vi skal eksplicit angive hvilke rettigheder vi har brug for.
# Dette f√∏lger "principle of least privilege" - kun de n√∏dvendige rettigheder.

permissions:
  # contents: read - Tillader at l√¶se repository indhold (checkout kode)
  contents: write

  # packages: write - Tillader at uploade til GitHub Container Registry
  # GHCR er en del af GitHub Packages, derfor denne permission
  packages: write


# ============================================================================
# JOBS - Hvad skal udf√∏res?
# ============================================================================
# Et workflow best√•r af et eller flere jobs.
# Hvert job k√∏rer p√• en separat virtuel maskine (runner).

jobs:
  test-code:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd
      - name: Set up JDK 21
        uses: actions/setup-java@dded0888837ed1f317902acf8a20df0ad188d165
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven
      - name: Build with Maven
        run: mvn -B package --file pom.xml -DskipTests

      # Optional: Uploads the full dependency graph to GitHub to improve the quality of Dependabot alerts this repository can receive
      - name: Update dependency graph
        uses: advanced-security/maven-dependency-submission-action@571e99aab1055c2e71a1e2309b9691de18d6b7d6

  # ==========================================================================
  # BUILD AND PUSH JOB
  # ==========================================================================
  # Dette job bygger Docker image, tester det, og pusher til GHCR.
  # Alle steps k√∏rer sekventielt p√• samme runner.

  build-and-push:

    # runs-on: Hvilken type maskine skal job k√∏re p√•?
    # ubuntu-latest er en gratis GitHub-hosted runner med Docker installeret.
    runs-on: ubuntu-latest
    needs: test-code

    # ========================================================================
    # STEPS - De individuelle trin i jobbet
    # ========================================================================
    # Steps k√∏rer i r√¶kkef√∏lge. Hvis et step fejler, stopper hele jobbet
    # (medmindre "if: always()" er sat).

    steps:
      # ======================================================================
      # STEP 1: CHECKOUT KODE
      # ======================================================================
      # Henter repository koden ned til runner maskinen.
      # Uden dette step har vi ingen filer at arbejde med!
      #
      # Hash-pinning: Vi bruger commit SHA i stedet for version tag (v4).
      # Dette er et sikkerhedskrav der beskytter mod supply-chain attacks.
      # Hvis nogen kompromitterer actions/checkout, kan de ikke √¶ndre
      # hvad vores pinned SHA peger p√•.

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      # ======================================================================
      # STEP 2: SETUP DOCKER BUILDX
      # ======================================================================
      # Docker Buildx er en udvidet version af docker build.
      # Det giver os:
      # - Bedre caching
      # - Multi-platform builds (linux/amd64, linux/arm64)
      # - Forbedret ydeevne
      #
      # Selvom vi ikke bruger alle features her, er det best practice.

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@c47758b77c9736f4b2ef4073d4d51994fabfe349 # v3.7.1

      # ======================================================================
      # STEP 3: BUILD DOCKER IMAGE
      # ======================================================================
      # Bygger Docker image fra vores Dockerfile.
      #
      # Image naming convention for GHCR:
      # ghcr.io/OWNER/IMAGE_NAME:TAG
      #
      # ${{ github.repository_owner }} - Dit GitHub brugernavn eller org navn
      # Dette g√∏r workflow genbrugeligt p√• tv√¶rs af forks.
      #
      # :latest - Tag der altid peger p√• nyeste version.
      # I produktion ville man ogs√• tagge med version/commit SHA.

      - name: Set lowercase owner
        run: echo "OWNER_LC=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_ENV

      - name: Build Docker image
        run: |
          docker build -t ghcr.io/${{ env.OWNER_LC }}/elvang-backend:latest .
          
          # ======================================================================
          # INTEGRATIONSTEST SEKTION
          # ======================================================================
          # F√∏r vi pusher image til GHCR, tester vi at det faktisk virker!
          # Vi starter hele stacken (database + backend + frontend) og
          # tjekker at vi kan n√• et endpoint.
          #
          # Dette er et krav fra projekt-dokumentet:
          # "Skal k√∏re en integrationstest af containeren hvor docker compose up -d
          # kaldes, der ventes lidt, og man kontakter et udvalgt endpoint."
          # ======================================================================
          
          # ======================================================================
          # STEP 5: START CONTAINERS
          # ======================================================================
          # Starter alle services defineret i compose.yaml.
          #
          # -d flag (detached): K√∏rer containers i baggrunden.
          # Uden -d ville workflow h√¶nge og vente p√• at containers stopper.
          #
          # Docker Compose vil:
          # 1. Starte MySQL database
          # 2. Vente p√• database healthcheck
          # 3. Starte backend (som connecter til database)
          # 4. Starte frontend
          
          # - name: Start containers
          #   run: |
          #     git clone https://github.com/sshine/PortfolioFrontend.git frontend
          #     docker compose up -d
          
          # ======================================================================
          # STEP 6: WAIT FOR SERVICES
          # ======================================================================
          # Selvom Docker Compose har depends_on, tager det tid for:
          # - MySQL at blive klar til connections
          # - Spring Boot at starte op
          # - Database migrations at k√∏re
          #
          # 30 sekunder er normalt nok, men kan justeres hvis n√∏dvendigt.
          # En mere avanceret l√∏sning ville polle endpoint indtil det svarer.
          
          # - name: Wait for services
          #   run: sleep 30
          
          # ======================================================================
          # STEP 7: TEST ENDPOINT (INTEGRATIONSTEST)
          # ======================================================================
          # Her tester vi at applikationen faktisk virker!
          #
          # curl options:
          # -s (silent): Ingen progress output
          # -o /dev/null: Ignorer response body
          # -w "%{http_code}": Print kun HTTP status kode
          #
          # || echo "000": Hvis curl fejler helt (fx connection refused),
          # return "000" i stedet for at crashe.
          #
          # Vi tjekker for HTTP 200 (OK). Hvis ikke:
          # 1. Print fejlbesked
          # 2. Vis container logs (til debugging)
          # 3. Exit med kode 1 (fejl) s√• workflow fejler
          #
          # VIGTIGT: Tilpas URL til et endpoint I faktisk har!
          # /api/health er bare et eksempel.
          
          # - name: Test endpoint
          #   run: |
          #     # Test at backend svarer med 200 OK
          #     HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/api/health || echo "000")
          
          #     if [ "$HTTP_STATUS" != "200" ]; then
          #       echo "Health check failed with status: $HTTP_STATUS"
          #       docker compose logs
          #       exit 1
        #     fi

      #     echo "Health check passed with status: $HTTP_STATUS"

      # ======================================================================
      # STEP 8: CLEANUP - STOP AND REMOVE CONTAINERS
      # ======================================================================
      # Rydder op efter testen, uanset om den lykkedes eller fejlede.
      #
      # if: always() - K√∏rer ALTID, selv hvis tidligere steps fejlede.
      # Dette sikrer at vi ikke efterlader k√∏rende containers.
      #
      # docker compose down -v:
      # - down: Stop og fjern containers
      # - -v: Fjern ogs√• volumes (test data)
      #
      # docker system prune -f:
      # - Fjerner ubrugte images, containers, networks
      # - -f: Force, ingen bekr√¶ftelse

      # - name: Stop and remove containers
      #   if: always()
      #   run: |
      #     docker compose down -v
      #     docker system prune -f

      # ======================================================================
      # PUSH TIL GHCR SEKTION
      # ======================================================================
      # Hvis integrationstesten lykkedes, uploader vi image til GHCR.
      # Vi pusher KUN ved push til main (ikke ved PRs).
      # ======================================================================

      # ======================================================================
      # STEP 9: LOGIN TIL GHCR
      # ======================================================================
      # For at pushe til GHCR skal vi autentificere.
      #
      # if: Betingelse for hvorn√•r step skal k√∏re.
      # - github.event_name == 'push': Kun ved push (ikke PR)
      # - github.ref == 'refs/heads/main': Kun p√• main branch
      #
      # Dette sikrer at vi ikke pusher:
      # - Ureviewed kode fra PRs
      # - Kode fra feature branches
      #
      # registry: ghcr.io - GitHub Container Registry
      # username: github.actor - Den bruger der trigerede workflow
      # password: GITHUB_TOKEN - Automatisk genereret token med packages:write

      - name: Log in to GHCR
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567 # v3.3.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ======================================================================
      # STEP 10: PUSH IMAGE TIL GHCR
      # ======================================================================
      # Uploader det byggede image til GitHub Container Registry.
      #
      # Efter dette step er image tilg√¶ngeligt p√•:
      # ghcr.io/teamornops/algenord-backend:latest
      #
      # Enhver server med Docker kan nu hente image med:
      # docker pull ghcr.io/teamornops/algenord-backend:latest
      #
      # Samme if-betingelse som login - kun push ved merge til main.

      - name: Set lowercase owner
        run: echo "OWNER_LC=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_ENV

      - name: Push to GHCR
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          docker push ghcr.io/${{ env.OWNER_LC }}/elvang-backend:latest
  

  # ============================================================================
  # N√ÜSTE SKRIDT: BRUG IMAGE P√Ö SERVER
  # ============================================================================
  # N√•r image er pushet til GHCR, kan du p√• din server (fx Digital Ocean):
  #
  # 1. Log ind p√• GHCR (√©n gang):
  #    echo $GITHUB_TOKEN | docker login ghcr.io -u USERNAME --password-stdin
  #
  # 2. I compose.prod.yaml, brug image i stedet for build:
  #    services:
  #      backend:
  #        image: ghcr.io/teamornops/algenord-backend:latest
  #
  # 3. Pull og start:
  #    docker compose -f compose.prod.yaml pull
  #    docker compose -f compose.prod.yaml up -d
  # ============================================================================

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push   # ‚Üê This ensures it runs after build-and-push
    steps:
      - name: üöÄ Deploy to server
        uses: appleboy/ssh-action@b60142998894e495c513803efc6d5d72a72c968a
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: 22
          script: |
            cd eksamen
            cd lagerSystem
            docker compose pull
            docker compose up -d
